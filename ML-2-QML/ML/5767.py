"""Hybrid convolutional filter with a sampler network.

This module merges the classical convolutional filter from Conv.py
with the sampler network from SamplerQNN.py, creating a single
drop‑in replacement for a quantum quanvolution layer.  The
convolutional kernel is generated using a simple quantum‑inspired
function, and the sampler produces a probability distribution
over the filter outputs.

Author: gpt-oss-20b
"""

from __future__ import annotations

import math
import numpy as np
import torch
from torch import nn
from torch.nn import functional as F


def _quantum_inspired_kernel(kernel_size: int, seed: int = 42) -> np.ndarray:
    """
    Generate a kernel that mimics the output of a small quantum circuit.
    The kernel values are derived from a deterministic pseudo‑random
    process that depends on the kernel size, producing a pattern that
    resembles interference fringes.

    Args:
        kernel_size: Size of the square kernel (e.g. 2 for a 2×2 filter).
        seed: Random seed for reproducibility.

    Returns:
        A 2‑D numpy array of shape (kernel_size, kernel_size).
    """
    rng = np.random.default_rng(seed)
    angles = rng.uniform(0, 2 * math.pi, size=(kernel_size, kernel_size))
    # Simulate a quantum rotation followed by a measurement
    kernel = np.sin(angles) * np.cos(angles)
    # Normalize to keep the convolution output in a reasonable range
    return kernel / np.max(np.abs(kernel))


class HybridConvSampler(nn.Module):
    """
    A PyTorch module that applies a quantum‑inspired convolution followed
    by a small sampler network.  The convolutional layer uses a kernel
    generated by `_quantum_inspired_kernel`, and the sampler produces
    a scalar probability for each convolution output patch.

    Parameters
    ----------
    kernel_size : int, default 2
        Size of the convolutional kernel.
    threshold : float, default 0.0
        Threshold used by the sampler network.
    hidden_units : int, default 4
        Number of hidden units in the sampler network.
    """

    def __init__(
        self,
        kernel_size: int = 2,
        threshold: float = 0.0,
        hidden_units: int = 4,
    ) -> None:
        super().__init__()
        self.kernel_size = kernel_size
        self.threshold = threshold

        # Build the convolutional layer with a fixed, quantum‑inspired kernel
        kernel = _quantum_inspired_kernel(kernel_size)
        self.conv = nn.Conv2d(
            in_channels=1,
            out_channels=1,
            kernel_size=kernel_size,
            bias=True,
            padding=0,
        )
        with torch.no_grad():
            self.conv.weight.copy_(torch.tensor(kernel).unsqueeze(0).unsqueeze(0))
            self.conv.bias.zero_()

        # Sampler network: a tiny feed‑forward network that maps the
        # flattened convolution output to a probability value.
        self.sampler = nn.Sequential(
            nn.Linear(kernel_size * kernel_size, hidden_units),
            nn.Tanh(),
            nn.Linear(hidden_units, 1),
            nn.Sigmoid(),
        )

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        Forward pass.

        Parameters
        ----------
        x : torch.Tensor
            Input tensor of shape (batch, 1, H, W).

        Returns
        -------
        torch.Tensor
            Probability values for each patch, averaged over the batch.
        """
        # Convolution
        conv_out = self.conv(x)  # shape: (batch, 1, H-k+1, W-k+1)
        batch, _, h, w = conv_out.shape
        conv_flat = conv_out.view(batch, -1)  # flatten each patch

        # Sampler
        probs = self.sampler(conv_flat)  # shape: (batch, 1)
        return probs.mean()

    def __repr__(self) -> str:
        return (
            f"{self.__class__.__name__}(kernel_size={self.kernel_size}, "
            f"threshold={self.threshold}, hidden_units={self.sampler[0].out_features})"
        )


__all__ = ["HybridConvSampler"]
