"""HybridSelfAttention: a quantum‑variational counterpart.

The implementation mirrors the classical API but uses Qiskit and Qutip
to construct a parameterised circuit, evaluate state‑vector expectations,
build fidelity graphs, and run quick evaluations with the FastBaseEstimator
utility.  Random network generation and training data creation are also
included for rapid prototyping.

Key features:
* Variational self‑attention circuit with RX/RY/RZ rotations and
  controlled‑X entanglement.
* Optional convolutional sub‑circuit generated by `qiskit.circuit.random.random_circuit`.
* Fidelity‑based graph construction for state‑vector outputs.
* Batch evaluation of arbitrary observables using `Statevector`.
* Lightweight estimator compatible with the original FastBaseEstimator API.
"""

from __future__ import annotations

import itertools
from typing import Iterable, List, Sequence, Tuple, Callable

import numpy as np
import qiskit
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute
from qiskit.circuit import Parameter
from qiskit.quantum_info import Statevector, Operator
import networkx as nx
import qutip as qt
import scipy as sc

ScalarObservable = Callable[[complex], complex]


# ----------------------------------------------------------------------
# Helper functions (adapted from GraphQNN)
# ----------------------------------------------------------------------
def _tensored_id(num_qubits: int) -> qt.Qobj:
    identity = qt.qeye(2 ** num_qubits)
    dims = [2] * num_qubits
    identity.dims = [dims.copy(), dims.copy()]
    return identity


def _tensored_zero(num_qubits: int) -> qt.Qobj:
    projector = qt.fock(2 ** num_qubits).proj()
    dims = [2] * num_qubits
    projector.dims = [dims.copy(), dims.copy()]
    return projector


def _swap_registers(op: qt.Qobj, source: int, target: int) -> qt.Qobj:
    if source == target:
        return op
    order = list(range(len(op.dims[0])))
    order[source], order[target] = order[target], order[source]
    return op.permute(order)


def _random_qubit_unitary(num_qubits: int) -> qt.Qobj:
    dim = 2 ** num_qubits
    matrix = sc.random.normal(size=(dim, dim)) + 1j * sc.random.normal(size=(dim, dim))
    unitary = sc.linalg.orth(matrix)
    qobj = qt.Qobj(unitary)
    dims = [2] * num_qubits
    qobj.dims = [dims.copy(), dims.copy()]
    return qobj


def _random_qubit_state(num_qubits: int) -> qt.Qobj:
    dim = 2 ** num_qubits
    amplitudes = sc.random.normal(size=(dim, 1)) + 1j * sc.random.normal(size=(dim, 1))
    amplitudes /= sc.linalg.norm(amplitudes)
    state = qt.Qobj(amplitudes)
    state.dims = [[2] * num_qubits, [1] * num_qubits]
    return state


def random_training_data(target_unitary: qt.Qobj, samples: int) -> List[Tuple[qt.Qobj, qt.Qobj]]:
    dataset: List[Tuple[qt.Qobj, qt.Qobj]] = []
    num_qubits = len(target_unitary.dims[0])
    for _ in range(samples):
        state = _random_qubit_state(num_qubits)
        dataset.append((state, target_unitary * state))
    return dataset


def random_network(qnn_arch: List[int], samples: int):
    target_unitary = _random_qubit_unitary(qnn_arch[-1])
    training_data = random_training_data(target_unitary, samples)

    unitaries: List[List[qt.Qobj]] = [[]]
    for layer in range(1, len(qnn_arch)):
        num_inputs = qnn_arch[layer - 1]
        num_outputs = qnn_arch[layer]
        layer_ops: List[qt.Qobj] = []
        for output in range(num_outputs):
            op = _random_qubit_unitary(num_inputs + 1)
            if num_outputs > 1:
                op = qt.tensor(_random_qubit_unitary(num_inputs + 1), _tensored_id(num_outputs - 1))
                op = _swap_registers(op, num_inputs, num_inputs + output)
            layer_ops.append(op)
        unitaries.append(layer_ops)

    return qnn_arch, unitaries, training_data, target_unitary


def state_fidelity(a: qt.Qobj, b: qt.Qobj) -> float:
    """Absolute squared overlap between pure states."""
    return abs((a.dag() * b)[0, 0]) ** 2


def fidelity_adjacency(
    states: Sequence[qt.Qobj],
    threshold: float,
    *,
    secondary: float | None = None,
    secondary_weight: float = 0.5,
) -> nx.Graph:
    graph = nx.Graph()
    graph.add_nodes_from(range(len(states)))
    for (i, s_i), (j, s_j) in itertools.combinations(enumerate(states), 2):
        fid = state_fidelity(s_i, s_j)
        if fid >= threshold:
            graph.add_edge(i, j, weight=1.0)
        elif secondary is not None and fid >= secondary:
            graph.add_edge(i, j, weight=secondary_weight)
    return graph


# ----------------------------------------------------------------------
# Quantum self‑attention circuit
# ----------------------------------------------------------------------
class HybridSelfAttention:
    """Quantum variational self‑attention that mirrors the classical API."""

    def __init__(
        self,
        n_qubits: int,
        kernel_size: int = 2,
        backend=None,
        shots: int = 1024,
        conv_threshold: float = 127,
    ) -> None:
        self.n_qubits = n_qubits
        self.kernel_size = kernel_size
        self.backend = backend or qiskit.Aer.get_backend("qasm_simulator")
        self.shots = shots
        self.conv_threshold = conv_threshold

        # Parameter placeholders
        self.rotation_params = [Parameter(f"rot{i}") for i in range(3 * n_qubits)]
        self.entangle_params = [Parameter(f"ent{i}") for i in range(n_qubits - 1)]

        # Base self‑attention circuit
        self._base_circuit = self._build_circuit(self.rotation_params, self.entangle_params)

        # Optional convolution sub‑circuit
        self._conv_circuit = self._build_conv_circuit(kernel_size)

    # ------------------------------------------------------------------
    def _build_circuit(
        self,
        rotation_params: Sequence[Parameter],
        entangle_params: Sequence[Parameter],
    ) -> QuantumCircuit:
        qr = QuantumRegister(self.n_qubits, "q")
        cr = ClassicalRegister(self.n_qubits, "c")
        circ = QuantumCircuit(qr, cr)

        # Single‑qubit rotations
        for i in range(self.n_qubits):
            circ.rx(rotation_params[3 * i], i)
            circ.ry(rotation_params[3 * i + 1], i)
            circ.rz(rotation_params[3 * i + 2], i)

        # Controlled‑X entanglement
        for i in range(self.n_qubits - 1):
            circ.crx(entangle_params[i], i, i + 1)

        circ.measure_all()
        return circ

    def _build_conv_circuit(self, kernel_size: int) -> QuantumCircuit:
        n = kernel_size ** 2
        qr = QuantumRegister(n, "q")
        circ = QuantumCircuit(qr)
        theta = [Parameter(f"theta{idx}") for idx in range(n)]
        for idx in range(n):
            circ.rx(theta[idx], idx)
        circ.barrier()
        # Random two‑qubit circuit to mix information
        circ += qiskit.circuit.random.random_circuit(n, 2)
        circ.measure_all()
        return circ

    # ------------------------------------------------------------------
    def run(
        self,
        rotation_params: np.ndarray,
        entangle_params: np.ndarray,
        data: np.ndarray | None = None,
    ) -> dict:
        """
        Execute the self‑attention circuit (and optional convolution) on a
        classical data array.

        Parameters
        ----------
        rotation_params : array shape (3*n_qubits,)
        entangle_params : array shape (n_qubits-1,)
        data : optional 2‑D array with shape (kernel_size, kernel_size)

        Returns
        -------
        dict
            {'attention': counts, 'convolution': conv_value (if data supplied)}
        """
        # Bind rotation/entangle parameters
        bound = self._base_circuit.assign_parameters(
            dict(zip(self.rotation_params, rotation_params)),
            inplace=False,
        )
        job = execute(bound, self.backend, shots=self.shots)
        attention_counts = job.result().get_counts(bound)

        result: dict = {"attention": attention_counts}

        # Convolution step
        if data is not None:
            n = self.kernel_size ** 2
            data_flat = np.reshape(data, (1, n))
            param_binds = []
            for vec in data_flat:
                bind = {theta: np.pi if v > self.conv_threshold else 0 for theta, v in zip(self._conv_circuit.parameters, vec)}
                param_binds.append(bind)

            conv_job = execute(self._conv_circuit, self.backend, shots=self.shots, parameter_binds=param_binds)
            conv_counts = conv_job.result().get_counts(self._conv_circuit)

            # Compute average number of |1> outcomes per shot
            total_ones = sum(sum(int(bit) for bit in key) * val for key, val in conv_counts.items())
            conv_value = total_ones / (self.shots * n)
            result["convolution"] = conv_value

        return result

    # ------------------------------------------------------------------
    # Fidelity graph construction
    # ------------------------------------------------------------------
    def fidelity_adjacency(
        self,
        states: Sequence[qt.Qobj],
        threshold: float,
        *,
        secondary: float | None = None,
        secondary_weight: float = 0.5,
    ) -> nx.Graph:
        return fidelity_adjacency(states, threshold, secondary=secondary, secondary_weight=secondary_weight)

    # ------------------------------------------------------------------
    # Estimator (from FastBaseEstimator)
    # ------------------------------------------------------------------
    def evaluate(
        self,
        observables: Iterable[Operator],
        parameter_sets: Sequence[Tuple[float,...]],
    ) -> List[List[complex]]:
        """
        Compute expectation values for each observable over each parameter set.
        Parameter sets correspond to the rotation and entangle parameters
        concatenated in a single tuple.
        """
        results: List[List[complex]] = []

        for params in parameter_sets:
            # Bind all parameters to the base circuit
            bound = self._base_circuit.assign_parameters(
                dict(zip(self.rotation_params + self.entangle_params, params)),
                inplace=False,
            )
            state = Statevector.from_instruction(bound)
            row = [state.expectation_value(obs) for obs in observables]
            results.append(row)

        return results

    # ------------------------------------------------------------------
    # Random network utilities
    # ------------------------------------------------------------------
    @staticmethod
    def random_network(qnn_arch: List[int], samples: int):
        return random_network(qnn_arch, samples)

    @staticmethod
    def random_training_data(target_unitary: qt.Qobj, samples: int):
        return random_training_data(target_unitary, samples)


__all__ = ["HybridSelfAttention"]
