"""Hybrid fraud‑detection model – quantum implementation.

This module implements the quantum side of the hybrid FraudDetection‑Hybrid model.
It builds a Qiskit ``QuantumCircuit`` that encodes the classical embedding
generated by the ``FraudDetectionHybridModel`` encoder and runs a depth‑controlled
ansatz for classification.  The interface mirrors the classical module so
researchers can swap implementations without changing downstream code.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, List, Tuple, Dict, Any

import numpy as np
from qiskit import QuantumCircuit, execute, Aer
from qiskit.circuit import ParameterVector

# --------------------------------------------------------------------------- #
# Parameter container – identical to the classical version.
# --------------------------------------------------------------------------- #
@dataclass
class FraudLayerParameters:
    """Parameters describing a single photonic layer, reused for consistency."""
    bs_theta: float
    bs_phi: float
    phases: Tuple[float, float]
    squeeze_r: Tuple[float, float]
    squeeze_phi: Tuple[float, float]
    displacement_r: Tuple[float, float]
    displacement_phi: Tuple[float, float]
    kerr: Tuple[float, float]

# --------------------------------------------------------------------------- #
# Quantum circuit builder
# --------------------------------------------------------------------------- #
def _clip(value: float, bound: float) -> float:
    return max(-bound, min(bound, value))

def build_fraud_detection_circuit(
    input_params: FraudLayerParameters,
    layers: Iterable[FraudLayerParameters],
    depth: int = 2,
) -> Tuple[QuantumCircuit, Dict[str, Any]]:
    """
    Build a Qiskit circuit that takes a 2‑dimensional classical embedding
    and produces a depth‑controlled variational circuit.

    Parameters
    ----------
    input_params : FraudLayerParameters
        Parameters for the first photonic‑inspired layer.
    layers : Iterable[FraudLayerParameters]
        Parameters for subsequent layers.
    depth : int
        Number of variational layers in the quantum ansatz.

    Returns
    -------
    circuit : QuantumCircuit
        The constructed circuit with symbolic parameters.
    param_bindings : dict
        Mapping from parameter names to the symbolic objects used in the circuit.
    """
    # Number of qubits equals the dimensionality of the embedding (2)
    num_qubits = 2
    circuit = QuantumCircuit(num_qubits)
    # Parameter vector for data encoding – one per qubit
    encoding = ParameterVector("x", num_qubits)
    # Parameter vector for variational angles
    var_params = ParameterVector("theta", num_qubits * depth)

    # --- Data encoding (analogous to photonic BS + R gates) ---
    for i in range(num_qubits):
        circuit.rx(encoding[i], i)
        circuit.rz(encoding[i], i)

    # --- Variational layers ---
    for d in range(depth):
        for i in range(num_qubits):
            circuit.ry(var_params[d * num_qubits + i], i)
        # Entangle neighbouring qubits
        for i in range(num_qubits - 1):
            circuit.cz(i, i + 1)

    # --- Measurement observables (Z on each qubit) ---
    circuit.measure_all()
    param_bindings = {
        "encoding": encoding,
        "var_params": var_params,
    }
    return circuit, param_bindings

# --------------------------------------------------------------------------- #
# Helper to bind a concrete embedding into the symbolic circuit
# --------------------------------------------------------------------------- #
def bind_params(circuit: QuantumCircuit, embedding: np.ndarray) -> QuantumCircuit:
    """
    Bind the two‑dimensional embedding to the encoding parameters of a circuit
    and return a new circuit ready for execution.
    """
    if embedding.shape!= (2,):
        raise ValueError("Embedding must be a 1‑D array of length 2.")
    bind_dict = {f"x{i}": float(v) for i, v in enumerate(embedding)}
    return circuit.bind_parameters(bind_dict)

# --------------------------------------------------------------------------- #
# Quantum hybrid model
# --------------------------------------------------------------------------- #
class FraudDetectionHybridModel:
    """
    Quantum‑side implementation of the hybrid fraud‑detection model.

    The class encapsulates a Qiskit circuit built with
    `build_fraud_detection_circuit`.  It exposes a minimal API that
    mimics the classical interface so that downstream code can
    interchangeably use the classical or quantum version.

    Parameters
    ----------
    input_params : FraudLayerParameters
        Parameters for the first photonic‑inspired layer.
    layers : Iterable[FraudLayerParameters]
        Parameters for subsequent layers.
    depth : int, optional
        Depth of the variational ansatz (default 2).
    """

    def __init__(
        self,
        input_params: FraudLayerParameters,
        layers: Iterable[FraudLayerParameters],
        depth: int = 2,
    ) -> None:
        self.circuit, self.param_bindings = build_fraud_detection_circuit(
            input_params, layers, depth=depth
        )

    # --------------------------------------------------------------------- #
    # Execution API
    # --------------------------------------------------------------------- #
    def run(
        self,
        embedding: np.ndarray,
        backend: str = "qasm_simulator",
        shots: int = 1024,
    ) -> np.ndarray:
        """
        Execute the circuit on a Qiskit backend and return the expectation
        values of the Z observable on each qubit.

        Parameters
        ----------
        embedding : np.ndarray
            1‑D array of length 2 containing the classical embedding.
        backend : str, optional
            Name of the Qiskit backend (default: ``qasm_simulator``).
        shots : int, optional
            Number of shots for the simulation (default: 1024).

        Returns
        -------
        np.ndarray
            Expectation values for each qubit, shape ``(2,)``.
        """
        bound_circuit = bind_params(self.circuit, embedding)
        job = execute(bound_circuit, Aer.get_backend(backend), shots=shots)
        result = job.result()
        counts = result.get_counts(bound_circuit)
        return _expectation_from_counts(counts, bound_circuit.num_qubits)

# --------------------------------------------------------------------------- #
# Helper for computing expectation from counts
# --------------------------------------------------------------------------- #
def _expectation_from_counts(counts: dict, num_qubits: int) -> np.ndarray:
    """Return the expectation value of Pauli‑Z on each qubit from measurement counts."""
    expectations = np.zeros(num_qubits, dtype=float)
    total = sum(counts.values())
    for bitstring, freq in counts.items():
        for i in range(num_qubits):
            bit = int(bitstring[::-1][i])  # LSB first
            expectations[i] += (1 if bit == 0 else -1) * freq
    return expectations / total

# --------------------------------------------------------------------------- #
# Fully connected layer inspired by FCL
# --------------------------------------------------------------------------- #
def FCL() -> QuantumCircuit:
    """
    Return a single‑qubit parameterised circuit that mimics a fully connected
    layer.  The circuit applies a Hadamard, a Ry rotation and a measurement
    that yields the expectation of Z.
    """
    qc = QuantumCircuit(1)
    theta = ParameterVector("theta", 1)
    qc.h(0)
    qc.ry(theta[0], 0)
    qc.measure_all()
    return qc

__all__ = ["FraudDetectionHybridModel", "FraudLayerParameters", "build_fraud_detection_circuit", "FCL"]
