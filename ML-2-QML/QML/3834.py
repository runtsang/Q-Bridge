"""Quantum variant of the graph neural network.

This module implements a quantum‑variational circuit that mirrors the
classical ``GraphQNNGen132``.  It uses torchquantum for device and
operations, and a superposition state encoder inspired by
``QuantumRegression``.  The adjacency matrix generated by
``fidelity_adjacency`` is used to weight the measurement
features before the classical head.
"""

from __future__ import annotations

import itertools
from collections.abc import Iterable, Sequence
from typing import List, Tuple

import networkx as nx
import numpy as np
import torch
import torch.nn as nn
import torchquantum as tq
from torchquantum import QuantumDevice, QuantumModule


# --------------------------------------------------------------------------- #
#  Utility functions – quantum data generation and fidelity graph construction
# --------------------------------------------------------------------------- #
def _tensored_id(num_qubits: int) -> tq.Qobj:
    """Identity operator on ``num_qubits`` qubits."""
    return tq.Qobject(qt.identity(2 ** num_qubits))


def _tensored_zero(num_qubits: int) -> tq.Qobj:
    """Zero projector on ``num_qubits`` qubits."""
    return tq.Qobject(qt.fock(2 ** num_qubits).proj())


def _random_qubit_unitary(num_qubits: int) -> tq.Qobj:
    """Random unitary on ``num_qubits`` qubits."""
    dim = 2 ** num_qubits
    matrix = np.random.normal(size=(dim, dim)) + 1j * np.random.normal(size=(dim, dim))
    unitary = np.linalg.qr(matrix)[0]
    return tq.Qobject(unitary)


def _random_qubit_state(num_qubits: int) -> tq.Qobj:
    """Random pure state on ``num_qubits`` qubits."""
    dim = 2 ** num_qubits
    vec = np.random.normal(size=(dim, 1)) + 1j * np.random.normal(size=(dim, 1))
    vec /= np.linalg.norm(vec)
    return tq.Qobject(vec)


def random_training_data(unitary: tq.Qobj, samples: int) -> List[Tuple[tq.Qobj, tq.Qobj]]:
    """Generate state → unitary * state pairs."""
    dataset: List[Tuple[tq.Qobj, tq.Qobj]] = []
    num_qubits = len(unitary.dims[0])
    for _ in range(samples):
        state = _random_qubit_state(num_qubits)
        dataset.append((state, unitary @ state))
    return dataset


def random_network(qnn_arch: List[int], samples: int) -> Tuple[List[int], List[List[tq.Qobj]], List[Tuple[tq.Qobj, tq.Qobj]], tq.Qobj]:
    """Build a random quantum circuit architecture and a target unitary."""
    target_unitary = _random_qubit_unitary(qnn_arch[-1])
    training_data = random_training_data(target_unitary, samples)

    unitaries: List[List[tq.Qobj]] = [[]]
    for layer in range(1, len(qnn_arch)):
        num_inputs = qnn_arch[layer - 1]
        num_outputs = qnn_arch[layer]
        layer_ops: List[tq.Qobj] = []
        for output in range(num_outputs):
            op = _random_qubit_unitary(num_inputs + 1)
            if num_outputs > 1:
                op = tq.tensor(_random_qubit_unitary(num_inputs + 1), _tensored_id(num_outputs - 1))
                op = _swap_registers(op, num_inputs, num_inputs + output)
            layer_ops.append(op)
        unitaries.append(layer_ops)
    return qnn_arch, unitaries, training_data, target_unitary


def _swap_registers(op: tq.Qobj, source: int, target: int) -> tq.Qobj:
    return op.permute([source, target] + list(range(len(op.dims[0]))))


def _partial_trace_keep(state: tq.Qobj, keep: Sequence[int]) -> tq.Qobj:
    if len(keep)!= len(state.dims[0]):
        return state.ptrace(list(keep))
    return state


def _partial_trace_remove(state: tq.Qobj, remove: Sequence[int]) -> tq.Qobj:
    keep = list(range(len(state.dims[0])))
    for index in sorted(remove, reverse=True):
        keep.pop(index)
    return _partial_trace_keep(state, keep)


def _layer_channel(
    qnn_arch: Sequence[int],
    unitaries: Sequence[Sequence[tq.Qobj]],
    layer: int,
    input_state: tq.Qobj,
) -> tq.Qobj:
    num_inputs = qnn_arch[layer - 1]
    num_outputs = qnn_arch[layer]
    state = tq.tensor(input_state, _tensored_zero(num_outputs))
    layer_unitary = unitaries[layer][0].copy()
    for gate in unitaries[layer][1:]:
        layer_unitary = gate @ layer_unitary
    return _partial_trace_remove(layer_unitary @ state @ layer_unitary.dag(), range(num_inputs))


def feedforward(
    qnn_arch: Sequence[int],
    unitaries: Sequence[Sequence[tq.Qobj]],
    samples: Iterable[Tuple[tq.Qobj, tq.Qobj]],
) -> List[List[tq.Qobj]]:
    """Propagate each sample through the quantum network."""
    stored_states: List[List[tq.Qobj]] = []
    for sample, _ in samples:
        layerwise = [sample]
        current_state = sample
        for layer in range(1, len(qnn_arch)):
            current_state = _layer_channel(qnn_arch, unitaries, layer, current_state)
            layerwise.append(current_state)
        stored_states.append(layerwise)
    return stored_states


def state_fidelity(a: tq.Qobj, b: tq.Qobj) -> float:
    """Squared overlap of two pure quantum states."""
    return abs((a.dag() @ b)[0, 0]) ** 2


def fidelity_adjacency(
    states: Sequence[tq.Qobj],
    threshold: float,
    *,
    secondary: float | None = None,
    secondary_weight: float = 0.5,
) -> nx.Graph:
    """Weighted graph from quantum state fidelities."""
    graph = nx.Graph()
    graph.add_nodes_from(range(len(states)))
    for (i, state_i), (j, state_j) in itertools.combinations(enumerate(states), 2):
        fid = state_fidelity(state_i, state_j)
        if fid >= threshold:
            graph.add_edge(i, j, weight=1.0)
        elif secondary is not None and fid >= secondary:
            graph.add_edge(i, j, weight=secondary_weight)
    return graph


# --------------------------------------------------------------------------- #
#  Dataset utilities – superposition regression data
# --------------------------------------------------------------------------- #
def generate_superposition_data(num_wires: int, samples: int) -> Tuple[np.ndarray, np.ndarray]:
    """Generate states of the form cos(theta)|0..0> + e^{i phi} sin(theta)|1..1>."""
    omega0 = np.zeros(2 ** num_wires, dtype=complex)
    omega0[0] = 1.0
    omega1 = np.zeros(2 ** num_wires, dtype=complex)
    omega1[-1] = 1.0

    thetas = 2 * np.pi * np.random.rand(samples)
    phis = 2 * np.pi * np.random.rand(samples)
    states = np.zeros((samples, 2 ** num_wires), dtype=complex)
    for i in range(samples):
        states[i] = np.cos(thetas[i]) * omega0 + np.exp(1j * phis[i]) * np.sin(thetas[i]) * omega1
    labels = np.sin(2 * thetas) * np.cos(phis)
    return states, labels


class RegressionDataset(torch.utils.data.Dataset):
    """Wraps the superposition data into a PyTorch dataset."""
    def __init__(self, samples: int, num_wires: int):
        self.states, self.labels = generate_superposition_data(num_wires, samples)

    def __len__(self) -> int:  # type: ignore[override]
        return len(self.states)

    def __getitem__(self, index: int):  # type: ignore[override]
        return {
            "states": torch.tensor(self.states[index], dtype=torch.cfloat),
            "target": torch.tensor(self.labels[index], dtype=torch.float32),
        }


# --------------------------------------------------------------------------- #
#  Main quantum model – variational graph neural network
# --------------------------------------------------------------------------- #
class GraphQNNGen132(tq.QuantumModule):
    """Quantum graph neural network with a classical regression head."""
    class QLayer(tq.QuantumModule):
        """Variational layer that acts on all wires."""
        def __init__(self, num_wires: int):
            super().__init__()
            self.num_wires = num_wires
            self.random_layer = tq.RandomLayer(n_ops=30, wires=list(range(num_wires)))
            self.rx = tq.RX(has_params=True, trainable=True)
            self.ry = tq.RY(has_params=True, trainable=True)

        def forward(self, qdev: QuantumDevice) -> None:
            self.random_layer(qdev)
            for w in range(self.num_wires):
                self.rx(qdev, wires=w)
                self.ry(qdev, wires=w)

    def __init__(self, num_wires: int):
        super().__init__()
        self.num_wires = num_wires
        # Encoder that maps a classical state vector into a quantum state
        self.encoder = tq.GeneralEncoder(tq.encoder_op_list_name_dict[f"{num_wires}xRy"])
        self.q_layer = self.QLayer(num_wires)
        self.measure = tq.MeasureAll(tq.PauliZ)
        self.head = nn.Linear(num_wires, 1)

    def forward(self, state_batch: torch.Tensor) -> torch.Tensor:
        """Encode, apply variational layer, measure, and regress."""
        bsz = state_batch.shape[0]
        qdev = QuantumDevice(n_wires=self.num_wires, bsz=bsz, device=state_batch.device)
        # Encode classical batch into quantum states
        self.encoder(qdev, state_batch)
        # Apply variational circuit
        self.q_layer(qdev)
        # Measure expectation values
        features = self.measure(qdev)
        # Classical head
        return self.head(features).squeeze(-1)


__all__ = [
    "GraphQNNGen132",
    "RegressionDataset",
    "generate_superposition_data",
    "random_network",
    "feedforward",
    "fidelity_adjacency",
]
