"""Quantum Graph Neural Network (QNN) module.

This module extends the original GraphQNN to provide a variational quantum circuit
that mirrors the classical architecture.  It keeps the same public API
(feedforward, fidelity_adjacency, random_network, random_training_data,
state_fidelity) but adds a `GraphQNN` class that can be trained with
PennyLane's autograd.
"""

from __future__ import annotations

import itertools
from collections.abc import Iterable, Sequence
from typing import List, Tuple

import networkx as nx
import numpy as np
import pennylane as qml
import pennylane.numpy as pnp

Tensor = np.ndarray


def random_training_data(unitary: qml.QNode, samples: int) -> List[Tuple[Tensor, Tensor]]:
    """Generate random input states and their targets under the unitary."""
    dataset: List[Tuple[Tensor, Tensor]] = []
    num_qubits = unitary.device.wires
    for _ in range(samples):
        # Random basis state encoded as binary vector
        inputs = np.random.randint(0, 2, size=num_qubits)
        target = unitary(inputs)
        dataset.append((inputs, target))
    return dataset


def random_network(qnn_arch: Sequence[int], samples: int):
    """Create a random target unitary and training data."""
    # Random unitary generated by a random circuit
    def target_circuit(inputs):
        qml.BasisState(inputs, wires=range(qnn_arch[-1]))
        for layer in range(3):
            for qubit in range(qnn_arch[-1]):
                qml.Rot(*np.random.normal(size=3), wires=qubit)
            for qubit in range(qnn_arch[-1] - 1):
                qml.CNOT(wires=[qubit, qubit + 1])
        return qml.state()
    target_unitary = qml.QNode(target_circuit, qml.device("default.qubit", wires=qnn_arch[-1]))
    training_data = random_training_data(target_unitary, samples)
    return list(qnn_arch), target_unitary, training_data, target_unitary


def state_fidelity(a: Tensor, b: Tensor) -> float:
    """Return the absolute squared overlap between pure states."""
    return np.abs(np.vdot(a, b)) ** 2


def fidelity_adjacency(
    states: Sequence[Tensor],
    threshold: float,
    *,
    secondary: float | None = None,
    secondary_weight: float = 0.5,
) -> nx.Graph:
    """Create a weighted adjacency graph from state fidelities."""
    graph = nx.Graph()
    graph.add_nodes_from(range(len(states)))
    for (i, s_i), (j, s_j) in itertools.combinations(enumerate(states), 2):
        fid = state_fidelity(s_i, s_j)
        if fid >= threshold:
            graph.add_edge(i, j, weight=1.0)
        elif secondary is not None and fid >= secondary:
            graph.add_edge(i, j, weight=secondary_weight)
    return graph


class GraphQNN:
    """Variational quantum graph neural network.

    Parameters
    ----------
    qnn_arch : Sequence[int]
        Layer sizes; the first element is the input dimensionality.
    device : str, optional
        Backend device for PennyLane (default: 'default.qubit').
    """

    def __init__(
        self,
        qnn_arch: Sequence[int],
        *,
        device: str | None = None,
    ):
        self.qnn_arch = list(qnn_arch)
        self.device = device or "default.qubit"
        self.num_qubits = qnn_arch[-1]
        self._build_circuit()

    def _build_circuit(self):
        """Create a variational circuit that mirrors the classical architecture."""
        num_layers = len(self.qnn_arch) - 1
        self.params = pnp.random.normal(size=(num_layers, self.num_qubits, 3))

        def circuit(inputs, params):
            qml.BasisState(inputs, wires=range(self.num_qubits))
            for layer, layer_params in zip(range(num_layers), params):
                for qubit in range(self.num_qubits):
                    qml.Rot(*layer_params[qubit], wires=qubit)
                for qubit in range(self.num_qubits - 1):
                    qml.CNOT(wires=[qubit, qubit + 1])
            return qml.state()

        self.qnode = qml.QNode(circuit, qml.device(self.device, wires=self.num_qubits))

    def forward(self, inputs: Tensor) -> Tensor:
        """Forward pass through the variational circuit."""
        return self.qnode(inputs, self.params)

    def train_step(self, inputs: Tensor, target: Tensor, lr: float = 1e-3):
        """Perform a single gradient step on the MSE loss."""
        loss = pnp.mean(pnp.square(self.forward(inputs) - target))
        grads = pnp.grad(lambda p: pnp.mean(pnp.square(self.qnode(inputs, p) - target)))(self.params)
        self.params -= lr * grads
        return float(loss)

    def __repr__(self) -> str:
        return f"GraphQNN(arch={self.qnn_arch}, device={self.device})"
