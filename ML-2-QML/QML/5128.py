"""HybridClassifier – quantum implementation.

This module constructs a variational circuit that matches the metadata
generated by the classical counterpart.  The circuit is built using a
data‑uploading ansatz with depth‑controlled rotation layers and entangling
CZ gates.  Evaluation is performed with Qiskit’s StatevectorEstimator,
and optional shot noise can be injected to emulate realistic measurement
statistics.  The public API mirrors the classical version for seamless
interchangeability.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, List, Sequence

from qiskit import QuantumCircuit
from qiskit.circuit import ParameterVector
from qiskit.quantum_info import SparsePauliOp, Statevector
from qiskit.primitives import Estimator as QiskitEstimator

# --------------------------------------------------------------------------- #
#   Data container – fraud‑detection style parameters (identical to ML side)
# --------------------------------------------------------------------------- #
@dataclass
class FraudLayerParameters:
    """Parameters for a single photonic layer, reused for quantum encoding."""
    bs_theta: float
    bs_phi: float
    phases: tuple[float, float]
    squeeze_r: tuple[float, float]
    squeeze_phi: tuple[float, float]
    displacement_r: tuple[float, float]
    displacement_phi: tuple[float, float]
    kerr: tuple[float, float]


# --------------------------------------------------------------------------- #
#   Quantum circuit builder – incremental data‑uploading ansatz
# --------------------------------------------------------------------------- #
def _build_quantum_circuit(num_qubits: int, depth: int) -> tuple[QuantumCircuit, list[ParameterVector], list[ParameterVector], list[SparsePauliOp]]:
    """Return a parameterised circuit and its metadata."""
    encoding = ParameterVector("x", num_qubits)
    weights = ParameterVector("theta", num_qubits * depth)

    qc = QuantumCircuit(num_qubits)
    for param, qubit in zip(encoding, range(num_qubits)):
        qc.rx(param, qubit)

    weight_idx = 0
    for _ in range(depth):
        for qubit in range(num_qubits):
            qc.ry(weights[weight_idx], qubit)
            weight_idx += 1
        for qubit in range(num_qubits - 1):
            qc.cz(qubit, qubit + 1)

    observables = [SparsePauliOp("I" * i + "Z" + "I" * (num_qubits - i - 1)) for i in range(num_qubits)]
    return qc, list(encoding), list(weights), observables


# --------------------------------------------------------------------------- #
#   Estimator wrapper – fast expectation evaluation with optional shot noise
# --------------------------------------------------------------------------- #
class FastEstimator:
    """
    Lightweight expectation value evaluator using Qiskit’s StatevectorEstimator.
    Supports optional Gaussian noise to emulate shot statistics.
    """

    def __init__(self, circuit: QuantumCircuit) -> None:
        self._circuit = circuit
        self._estimator = QiskitEstimator()
        self._parameters = list(circuit.parameters)

    def _bind(self, parameter_values: Sequence[float]) -> QuantumCircuit:
        if len(parameter_values)!= len(self._parameters):
            raise ValueError("Parameter count mismatch for bound circuit.")
        mapping = dict(zip(self._parameters, parameter_values))
        return self._circuit.assign_parameters(mapping, inplace=False)

    def evaluate(
        self,
        observables: Iterable[SparsePauliOp],
        parameter_sets: Sequence[Sequence[float]],
        *,
        shots: int | None = None,
        seed: int | None = None,
    ) -> List[List[complex]]:
        """Compute expectation values for each parameter set and observable."""
        results: List[List[complex]] = []

        for values in parameter_sets:
            bound_qc = self._bind(values)
            state = Statevector.from_instruction(bound_qc)
            row = [state.expectation_value(obs) for obs in observables]
            results.append(row)

        if shots is None:
            return results

        rng = None if seed is None else torch.Generator().manual_seed(seed)
        noisy: List[List[complex]] = []
        for row in results:
            noisy_row = [complex(rng.normal(0, 1 / shots) + float(val.real)) for val in row]
            noisy.append(noisy_row)

        return noisy


# --------------------------------------------------------------------------- #
#   Main hybrid classifier – quantum implementation
# --------------------------------------------------------------------------- #
class HybridClassifier:
    """
    Quantum hybrid classifier.

    Parameters
    ----------
    num_qubits : int
        Number of qubits (must match feature dimensionality).
    depth : int
        Depth of the variational ansatz.
    fraud_params : Iterable[FraudLayerParameters] | None
        Optional photonic parameters used to initialise the first layer
        (currently unused but retained for API symmetry).
    """

    def __init__(
        self,
        num_qubits: int,
        depth: int,
        *,
        fraud_params: Iterable[FraudLayerParameters] | None = None,
    ) -> None:
        self._circuit, self._encoding, self._weights, self._observables = _build_quantum_circuit(num_qubits, depth)
        self.estimator = FastEstimator(self._circuit)

    @property
    def encoding(self) -> list[ParameterVector]:
        """Parameter vectors used for data encoding."""
        return self._encoding

    @property
    def weight_sizes(self) -> list[int]:
        """Number of variational parameters per layer."""
        return [len(self._weights) // len(self._encoding)]

    @property
    def observables(self) -> list[SparsePauliOp]:
        """Observables whose expectation values form the logits."""
        return self._observables

    def evaluate(
        self,
        parameter_sets: Sequence[Sequence[float]],
        *,
        shots: int | None = None,
        seed: int | None = None,
    ) -> List[List[complex]]:
        """
        Evaluate the quantum classifier on a batch of parameter sets.

        Parameters
        ----------
        parameter_sets : Sequence[Sequence[float]]
            Flattened vector of variational parameters for each evaluation.
        shots : int | None, optional
            If provided, Gaussian noise with variance 1/shots is added.
        seed : int | None, optional
            Seed for reproducible noise.

        Returns
        -------
        List[List[complex]]
            Expectation values of the observables for each parameter set.
        """
        return self.estimator.evaluate(
            observables=self._observables,
            parameter_sets=parameter_sets,
            shots=shots,
            seed=seed,
        )
